package com.kdt.yts.YouSumback.service;

import com.kdt.yts.YouSumback.model.dto.request.UserAnswerDTO;
import com.kdt.yts.YouSumback.model.dto.response.*;
import com.kdt.yts.YouSumback.model.entity.*;
import com.kdt.yts.YouSumback.repository.*;
import com.kdt.yts.YouSumback.model.dto.request.QuizRequestDTO;
import com.kdt.yts.YouSumback.model.dto.request.SummaryRequestDTO;
import com.kdt.yts.YouSumback.service.client.OpenAIClient;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class SummaryServiceImpl implements SummaryService {

    private final OpenAIClient openAIClient;
    private final AnswerOptionRepository answerOptionRepository;
    private final TagRepository tagRepository;
    private final SummaryArchiveRepository summaryArchiveRepository;
    private final SummaryArchiveTagRepository summaryArchiveTagRepository;
    private final UserRepository userRepository;
    private final AudioTranscriptRepository audioTranscriptRepository;
    private final SummaryRepository summaryRepository;
    private final QuizRepository quizRepository;
    private final UserActivityLogRepository userActivityLogRepository;
    private final VideoRepository videoRepository;

    @Override
    @Transactional
    public SummaryResponseDTO summarize(SummaryRequestDTO request, Long userId) {
        String originalUrl = request.getOriginalUrl();
        String userPrompt = request.getUserPrompt();
        SummaryType summaryType = request.getSummaryType();

        System.out.println(">>> SummaryServiceImpl.summarize ÏßÑÏûÖ - URL: " + originalUrl + ", User ID: " + userId);

        AudioTranscript transcript = audioTranscriptRepository.findByVideo_OriginalUrl(originalUrl)
                .orElseThrow(() -> new RuntimeException("AudioTranscript not found for URL: " + originalUrl));

        String text;
        if (summaryType == SummaryType.TIMELINE) {
            String videoId = transcript.getVideo().getYoutubeId();
            String lang = transcript.getVideo().getOriginalLanguageCode();
            Path vttPath = Paths.get("src", "main", "resources", "textfiles", videoId + "." + lang + ".vtt");

            try {
                if (Files.exists(vttPath)) {
                    text = Files.readString(vttPath, StandardCharsets.UTF_8);
                    System.out.println("‚úÖ TIMELINE summary: Loaded VTT file from: " + vttPath);
                } else {
                    Path cleanedPath = Paths.get(transcript.getTranscriptPath());
                    System.err.println("‚ö†Ô∏è VTT file not found for TIMELINE summary at " + vttPath + ". Falling back to cleaned text from " + cleanedPath);
                    text = Files.readString(cleanedPath, StandardCharsets.UTF_8);
                }
            } catch (IOException e) {
                System.err.println("‚ùå Error reading transcript file for TIMELINE summary: " + e.getMessage());
                throw new RuntimeException("Failed to read transcript file for TIMELINE summary.", e);
            }
        } else {
            if (transcript.getTranscriptPath() == null || transcript.getTranscriptPath().isEmpty()) {
                System.err.println("‚ùå AudioTranscript has no file path for URL: " + originalUrl);
                throw new RuntimeException("No transcript file path found for URL: " + originalUrl + ". Summary failed.");
            }

            try {
                Path filePath = Paths.get(transcript.getTranscriptPath());
                text = Files.readString(filePath, StandardCharsets.UTF_8);
                System.out.println("‚úÖ Transcript text loaded from file path: " + filePath);
            } catch (IOException e) {
                System.err.println("‚ùå Error reading transcript file from path: " + transcript.getTranscriptPath() + " - " + e.getMessage());
                throw new RuntimeException("Failed to read transcript text from file.", e);
            }
        }
        Long transcriptId = transcript.getId();

        System.out.println("‚úÖ Transcript found/processed. ID: " + transcriptId);

        String prompt = buildPrompt(userPrompt, summaryType);

        String finalSummary;
        if (summaryType == SummaryType.TIMELINE) {
            System.out.println("‚úÖ TIMELINE summary: Bypassing chunking and calling AI with full VTT content.");
            finalSummary = callOpenAISummary(prompt + "\n\n" + text);
        } else {
            List<String> chunks = splitTextIntoChunks(text, 1000);
            List<String> partialSummaries = new ArrayList<>();

            for (String chunk : chunks) {
                partialSummaries.add(callOpenAISummary(prompt + "\n\n" + chunk));
            }
            String finalSummaryPrompt = "Îã§ÏùåÏùÄ Í∞Å Î∂ÄÎ∂ÑÏóê ÎåÄÌïú ÏöîÏïΩÏûÖÎãàÎã§. Ïù¥ ÏöîÏïΩÎì§ÏùÑ ÌïòÎÇòÎ°ú Ìï©Ï≥êÏÑú ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏµúÏ¢Ö ÏöîÏïΩÏùÑ ÎßåÎì§Ïñ¥Ï£ºÏÑ∏Ïöî:\n\n" + String.join("\n---\n", partialSummaries);
            finalSummary = callOpenAISummary(finalSummaryPrompt);
        }
        System.out.println("‚úÖ Final Summary Generated. Length: " + finalSummary.length());

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found for ID: " + userId));

        String videoLanguageCode = transcript.getVideo().getOriginalLanguageCode();
        Summary summary = Summary.builder()
                .user(user)
                .audioTranscript(transcript)
                .summaryText(finalSummary)
                .summaryType(summaryType)
                .userPrompt(userPrompt)
                .createdAt(LocalDateTime.now())
                .languageCode(videoLanguageCode != null ? videoLanguageCode : "ko")
                .build();
        Summary saved = summaryRepository.save(summary);
        System.out.println("‚úÖ Summary Saved. ID: " + saved.getId());

        SummaryArchive archive = new SummaryArchive();
        archive.setUser(user);
        archive.setSummary(saved);
        archive.setLastViewedAt(LocalDateTime.now());
        summaryArchiveRepository.save(archive);
        System.out.println("‚úÖ SummaryArchive Saved. User ID: " + user.getId() + ", Summary ID: " + saved.getId());

        List<String> hashtags = extractTagsWithLLM(finalSummary).stream().distinct().toList();
        System.out.println("‚úÖ Hashtags Extracted: " + hashtags);

        for (String keyword : hashtags) {
            Tag tag = findOrCreateTag(keyword);

            SummaryArchiveTag summaryArchiveTag = new SummaryArchiveTag(archive.getId(), tag.getId());
            summaryArchiveTagRepository.save(summaryArchiveTag);
        }
        System.out.println("‚úÖ Tags Processed.");

        UserActivityLog log = UserActivityLog.builder()
                .user(user)
                .activityType("SUMMARY_CREATED")
                .targetEntityType("SUMMARY")
                .targetEntityIdInt(saved.getId())
                .activityDetail("ÏöîÏïΩ ÏÉùÏÑ± ÏôÑÎ£å: " + summaryType)
                .details(String.format("""
{
"summaryType": "%s",
"videoId": %d,
"videoTitle": "%s"
}
""", summaryType, transcript.getVideo().getId(), transcript.getVideo().getTitle()))
                .createdAt(LocalDateTime.now())
                .build();
        userActivityLogRepository.save(log);
        System.out.println("‚úÖ UserActivityLog Saved.");

        return new SummaryResponseDTO(
                saved.getId(),
                transcript.getId(),
                transcript.getVideo().getId(),
                finalSummary,
                hashtags,
                transcript.getVideo().getTitle(),
                transcript.getVideo().getThumbnailUrl(),
                transcript.getVideo().getUploaderName(),
                transcript.getVideo().getViewCount(),
                transcript.getVideo().getOriginalLanguageCode(),
                summary.getCreatedAt()
        );
    }

    private String buildPrompt(String userPrompt, SummaryType summaryType) {
        String formatInstruction = switch (summaryType) {
            case BASIC -> """
                    **üîπ Í∏∞Î≥∏ ÏöîÏïΩ (BASIC)**
                    - ÏûêÏó∞Ïä§Îü¨Ïö¥ Îã®ÎùΩ ÌòïÌÉúÏùò ÏöîÏïΩ
                    - ÎßàÌÅ¨Îã§Ïö¥ Î¨∏Îã® Ïä§ÌÉÄÏùº Ïú†ÏßÄ (Ï§ÑÎ∞îÍøàÏùÄ Î¨∏Îã® Îã®ÏúÑ)
                    """;
            case THREE_LINE -> """
                    **üîπ 3Ï§Ñ ÏöîÏïΩ (THREE_LINE)**
                    - ÌïµÏã¨ ÎÇ¥Ïö©ÏùÑ ÏÑ∏ Î¨∏Ïû•ÏúºÎ°ú ÎÇòÎà† Ï§ÑÎ∞îÍøàÌïòÏó¨ Ï∂úÎ†•
                    - Í∞Å Î¨∏Ïû•ÏùÄ Ï§ÑÎ∞îÍøà(\\n)ÏúºÎ°ú Íµ¨Î∂Ñ
                    - Ïòà:
                      Ï≤´ Î≤àÏß∏ ÌïµÏã¨ ÎÇ¥Ïö© ÏöîÏïΩ.\\n
                      Îëê Î≤àÏß∏ ÌïµÏã¨ ÎÇ¥Ïö© ÏöîÏïΩ.\\n
                      ÏÑ∏ Î≤àÏß∏ ÌïµÏã¨ ÎÇ¥Ïö© ÏöîÏïΩ.
                    """;
            case KEYWORD -> """
                    **üîπ ÌÇ§ÏõåÎìú ÏöîÏïΩ (KEYWORD)**
                    - ÏÉÅÎã®Ïóê Í¥ÄÎ†® ÌïµÏã¨ ÌÇ§ÏõåÎìú 3~5Í∞ú ÎÇòÏó¥ (ÏâºÌëúÎ°ú Íµ¨Î∂Ñ)
                    - Í∑∏ ÏïÑÎûò ÏùºÎ∞ò ÏöîÏïΩ Î¨∏Îã® Ï∂úÎ†•
                    - ÏöîÏïΩ Î¨∏Îã® ÏïàÏóê Îì±Ïû•ÌïòÎäî ÌÇ§ÏõåÎìúÎäî ÍµµÏùÄ Í∏ÄÏî® Ï≤òÎ¶¨
                    - ÎßàÌÅ¨Îã§Ïö¥ ÏòàÏãú:
                      **Keywords:** AI, ÏöîÏïΩ, ÌïôÏäµ, Ïú†ÌäúÎ∏å, ÏûêÎèôÌôî

                      Î≥∏ ÏòÅÏÉÅÏùÄ **AI** Í∏∞Ïà†ÏùÑ ÌôúÏö©Ìï¥ **ÏöîÏïΩ**ÏùÑ ÏûêÎèôÏúºÎ°ú ÏàòÌñâÌïòÎ©∞, ÏÇ¨Ïö©ÏûêÏùò **ÌïôÏäµ** Ìö®Ïú®ÏùÑ ÎÜíÏù¥Îäî **ÏûêÎèôÌôî**Îêú Íµ¨Ï°∞Î•º ÏÑ§Î™ÖÌï©ÎãàÎã§.
                    """;
            case TIMELINE -> """
                    **üîπ ÌÉÄÏûÑÎùºÏù∏ ÏöîÏïΩ (TIMELINE)**
                    - ÏïÑÎûò WEBVTT ÌòïÏãù Ïä§ÌÅ¨Î¶ΩÌä∏Ïùò ÎÇ¥Ïö©ÏùÑ **ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ(Ïòà: 00:00:15.480 --> 00:00:17.440)Î•º Í∏∞Ï§ÄÏúºÎ°ú** ÏãúÍ∞ÑÏùò ÌùêÎ¶ÑÏóê Îî∞Îùº ÏöîÏïΩÌï¥Ï£ºÏÑ∏Ïöî.
                    - Í∞Å ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÏùò ÎÇ¥Ïö©ÏùÄ Ìï¥Îãπ ÏãúÍ∞ÑÎåÄÏùò ÌïµÏã¨Ï†ÅÏù∏ ÎÇ¥Ïö©ÏùÑ Ìïú Î¨∏Ïû•ÏúºÎ°ú Í∞ÑÍ≤∞ÌïòÍ≤å ÏöîÏïΩÌï¥Ïïº Ìï©ÎãàÎã§.
                    - **WEBVTT Ìó§ÎçîÎÇò NOTE, STYLE Í∞ôÏùÄ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Îäî Î¨¥ÏãúÌïòÍ≥†, ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÏôÄ ÎåÄÌôî ÎÇ¥Ïö©Îßå ÏÇ¨Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.**
                    - ÏµúÏ¢Ö Í≤∞Í≥ºÎäî ÎßàÌÅ¨Îã§Ïö¥ Î™©Î°ù ÌòïÏãùÏúºÎ°ú Ï†ïÎ¶¨Ìï¥Ï£ºÏÑ∏Ïöî.
                    - ÌòïÏãù ÏòàÏãú:
                      - **00:15** - ÏÑ†Î£®ÌîÑ Ìã∏ÌåÖ Í∏∞Îä• ÏÑ§Î™Ö
                      - **01:05** - ÍπÄÏÑúÎ¶º Î∞©ÏßÄ Î≤ÑÌäº ÏÇ¨Ïö©Î≤ï
                      - **01:50** - Ïú†Îßâ Ï†úÍ±∞Ïùò Ï§ëÏöîÏÑ± Ïñ∏Í∏â
                    """;
        };

        return String.format("""
        ÏïÑÎûò ÌÖçÏä§Ìä∏Î•º Í∏∞Î∞òÏúºÎ°ú ÏöîÏïΩÏùÑ ÏÉùÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.
        ÏöîÏïΩÏùÄ ÏöîÏïΩ Ïú†Ìòï(SummaryType) Ïóê Îî∞Îùº Í∞ÅÍ∞Å Îã§Î•∏ Ìè¨Îß∑ÏúºÎ°ú ÎßàÌÅ¨Îã§Ïö¥ ÌòïÏãùÏúºÎ°ú Ï∂úÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî.
        ÏöîÏïΩ ÌÖçÏä§Ìä∏Îäî ÌïôÏäµ Î≥¥Ï°∞ Î™©Ï†ÅÏù¥Î©∞, ÏÇ¨Ïö©ÏûêÍ∞Ä ÏùΩÍ∏∞ Ìé∏ÌïòÍ≥† ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú Î™ÖÌôïÌïòÍ≤å Ï†ÑÎã¨Îê† Ïàò ÏûàÎèÑÎ°ù Íµ¨ÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.

        ÏÇ¨Ïö©Ïûê ÎßûÏ∂§ ÏöîÏ≤≠: "%s"

        %s

        ‚ö†Ô∏è Ï∂úÎ†•ÏùÄ Î∞òÎìúÏãú ÎßàÌÅ¨Îã§Ïö¥ Ïä§ÌÉÄÏùºÏùÑ ÏßÄÏºúÏ£ºÏÑ∏Ïöî.
        ‚ö†Ô∏è Î∂àÌïÑÏöîÌïú Î¨∏Ïû•Ïù¥ÎÇò ÌòïÏãùÏùÄ ÏÉùÎûµÌïòÍ≥†, ÏúÑÏùò Ìè¨Îß∑Îßå Ï∂©Ïã§Ìûà Î∞òÏòÅÌï¥Ï£ºÏÑ∏Ïöî.

        Îã§ÏùåÏùÄ Ïú†ÌäúÎ∏å ÏòÅÏÉÅÏùò Ï†ÑÏ≤¥ Ïä§ÌÅ¨Î¶ΩÌä∏ÏûÖÎãàÎã§:
        ----
        """, userPrompt, formatInstruction);
    }

    private List<String> extractTagsWithLLM(String summaryText) {
        List<String> baseTags = List.of(
                "Í≤ΩÏ†ú", "Ï£ºÏãù", "Ìà¨Ïûê", "Í∏àÏúµ", "Î∂ÄÎèôÏÇ∞",
                "Ïù∏Í≥µÏßÄÎä•", "Î®∏Ïã†Îü¨Îãù", "Îî•Îü¨Îãù", "ÌîÑÎ°úÍ∑∏ÎûòÎ∞ç", "ÏΩîÎî©",
                "ÍµêÏú°", "ÌïôÏäµ", "ÏãúÌóòÎåÄÎπÑ", "ÏûêÍ∏∞Í≥ÑÎ∞ú", "ÏãúÍ∞ÑÍ¥ÄÎ¶¨",
                "Ï†ïÏπò", "Íµ≠Ï†úÏ†ïÏÑ∏", "ÏÇ¨ÌöåÏù¥Ïäà", "ÌôòÍ≤Ω", "Í∏∞ÌõÑÎ≥ÄÌôî",
                "Ïú§Î¶¨", "Ïã¨Î¶¨Ìïô", "Ï≤†Ìïô", "Î¨∏Ìôî", "Ïó≠ÏÇ¨",
                "ITÍ∏∞Ïà†", "Îç∞Ïù¥ÌÑ∞Î∂ÑÏÑù", "UXÎîîÏûêÏù∏", "Ï∞ΩÏóÖ", "ÎßàÏºÄÌåÖ"
        );
        String baseTagList = String.join(", ", baseTags);
        String prompt = String.format("""
Îã§Ïùå ÎÇ¥Ïö©ÏùÑ ÎåÄÌëúÌïòÎäî ÌïµÏã¨ Ìï¥ÏãúÌÉúÍ∑∏ 3Í∞úÎ•º Ï∂îÏ∂úÌï¥Ï§ò.
**Î∞òÎìúÏãú ÏïÑÎûò Í∏∞Î≥∏ ÌÉúÍ∑∏ Î™©Î°ù ÏïàÏóêÏÑúÎßå Í≥®ÎùºÏïº Ìï¥.**
ÏùëÎãµ ÌòïÏãùÏùÄ Ìï¥ÏãúÌÉúÍ∑∏ Ïù¥Î¶ÑÎßå ÏâºÌëúÎ°ú Íµ¨Î∂ÑÌï¥ÏÑú Ï§ò. ÏòàÏãú: Ìà¨Ïûê, Ïù∏Í≥µÏßÄÎä•, Ïú§Î¶¨

[Í∏∞Î≥∏ ÌÉúÍ∑∏ Î™©Î°ù]
%s

[ÏöîÏïΩ ÎÇ¥Ïö©]
%s
""", baseTagList, summaryText);

        String response = openAIClient.chat(prompt).block();
        return Arrays.stream(response.split("[,\\n]"))
                .map(String::trim)
                .filter(s -> !s.isBlank())
                .limit(3)
                .toList();
    }

    public Optional<SummaryArchive> findSummaryArchiveByUserAndSummary(Long userId, Summary summary) {
        return summaryArchiveRepository.findByUser_IdAndSummary_Id(userId, summary.getId());
    }

    @Transactional
    public List<QuizResponseDTO> generateFromSummary(QuizRequestDTO request) {
        Summary summary = summaryRepository.findById(request.getSummaryId())
                .orElseThrow(() -> new RuntimeException("Summary not found"));

        String prompt = String.format("""
ÏïÑÎûò ÏöîÏïΩÎ¨∏ÏùÑ Î∞îÌÉïÏúºÎ°ú Í∞ùÍ¥ÄÏãù ÌÄ¥Ï¶àÎ•º %dÍ∞ú ÎßåÎì§Ïñ¥Ï§ò.
Î∞òÎìúÏãú ÏïÑÎûò ÌòïÏãùÎßå ÏßÄÏºúÏÑú Ï∂úÎ†•Ìï¥Ï§ò. Î∂àÌïÑÏöîÌïú ÏÑ§Î™ÖÏùÄ Ïì∞ÏßÄ Îßà.

Q: Ïù∏Í≥µÏßÄÎä•Ïù¥ ÏµúÍ∑º Î∞úÏ†ÑÌïú Î∂ÑÏïºÎäî Î¨¥ÏóáÏù∏Í∞ÄÏöî?
1. ÏûêÏó∞Ïñ¥ Ï≤òÎ¶¨
2. ÎÜçÏóÖ Í∏∞Ïà†
3. Í≥†Ï†Ñ Î¨∏Ìïô
4. Ïä§Ìè¨Ï∏† Î∂ÑÏÑù
Ï†ïÎãµ: 1

Q: Ïù∏Í≥µÏßÄÎä•Ïùò Î∞úÏ†ÑÏúºÎ°ú Îì±Ïû•Ìïú ÏÑúÎπÑÏä§Í∞Ä ÏïÑÎãå Í≤ÉÏùÄ?
1. Ï±óÎ¥á
2. Í∏∞Í≥Ñ Î≤àÏó≠
3. ÏùåÏÑ± Ïù∏Ïãù
4. ÏÜêÍ∏ÄÏî® Ïó∞ÏäµÏû•
Ï†ïÎãµ: 4

[ÏöîÏïΩÎ¨∏ ÏãúÏûë]
%s
[ÏöîÏïΩÎ¨∏ ÎÅù]
""", request.getNumberOfQuestions(), summary.getSummaryText());

        System.out.println(">>>> Sending Quiz Prompt to AI:\n" + prompt);
        String aiResponseQuiz = openAIClient.chat(prompt).block();
        System.out.println(">>>> AI Quiz Response:\n" + aiResponseQuiz);
        String[] rawBlocks = aiResponseQuiz.split("(?m)(?=Q:)");
        List<String> quizBlocks = new ArrayList<>();
        for (String b : rawBlocks) {
            String trimmed = b.strip();
            if (!trimmed.isEmpty()) {
                quizBlocks.add(trimmed);
            }
        }

        Quiz quiz = Quiz.builder()
                .summary(summary)
                .title("AI ÏûêÎèô ÏÉùÏÑ± ÌÄ¥Ï¶à")
                .createdAt(LocalDateTime.now())
                .build();

        List<Question> questionList = new ArrayList<>();
        for (String block : quizBlocks) {
            try {
                String[] lines = block.split("\\r?\\n");
                if (lines.length < 2) {
                    System.out.println("‚ö†Ô∏è Î∏îÎ°ù ÎùºÏù∏ Î∂ÄÏ°±: " + block);
                    continue;
                }
                String firstLine = lines[0].trim();
                String questionText;
                if (firstLine.startsWith("Q:")) {
                    questionText = firstLine.substring(2).trim();
                } else {
                    continue; // "Q:"Î°ú ÏãúÏûëÌïòÏßÄ ÏïäÏúºÎ©¥ Ïä§ÌÇµ
                }

                List<AnswerOption> options = new ArrayList<>();
                Integer answerIndex = null;
                for (String line : Arrays.copyOfRange(lines, 1, lines.length)) {
                    line = line.trim();
                    if (line.matches("^[0-9]+\\.\\s+.*")) {
                        String optText = line.replaceFirst("^[0-9]+\\.\\s*", "");
                        AnswerOption opt = AnswerOption.builder()
                                .optionText(optText)
                                .isCorrect(false)
                                .build();
                        options.add(opt);
                    }
                    else if (line.startsWith("Ï†ïÎãµ")) {
                        String digits = line.replaceAll("[^0-9]", "");
                        if (!digits.isEmpty()) {
                            answerIndex = Integer.parseInt(digits);
                        }
                    }
                }
                if (answerIndex != null && answerIndex > 0 && answerIndex <= options.size()) {
                    options.get(answerIndex - 1).setIsCorrect(true);
                } else {
                    System.out.println("‚ö†Ô∏è Ï†ïÎãµ Ïù∏Îç±Ïä§ ÌååÏã± Ïã§Ìå®: " + block);
                    continue; // Ï†ïÎãµ ÌååÏã± Ïã§Ìå® Ïãú Ïù¥ Î∏îÎ°ù Ïä§ÌÇµ
                }
                Question q = Question.builder()
                        .quiz(quiz)
                        .questionText(questionText)
                        .languageCode("ko")
                        .options(options)
                        .build();

                for (AnswerOption option : options) {
                    option.setQuestion(q);
                }
                questionList.add(q);

            } catch (Exception e) {
                System.err.println("ÌÄ¥Ï¶à Î∏îÎ°ù ÌååÏã± Ï§ë ÏòàÏô∏ Î∞úÏÉù: " + block);
                e.printStackTrace();
            }
        }
        quiz.setQuestions(questionList);

        quizRepository.save(quiz);

        return quiz.getQuestions().stream()
                .map(q -> {
                    List<OptionDTO> optionDTOs = q.getOptions().stream()
                            .map(o -> new OptionDTO(o.getId(), o.getOptionText()))
                            .collect(Collectors.toList());
                    // Ïù¥ Î∂ÄÎ∂ÑÏùÄ QuestionDTOÎ•º ÏÉùÏÑ±Ìï¥Ïïº Ìï©ÎãàÎã§.
                    // Í∑∏Îü¨ÎÇò Î∞òÌôò ÌÉÄÏûÖÏù¥ List<QuizResponseDTO>Ïù¥ÎØÄÎ°ú, Ï†ÑÏ≤¥ Íµ¨Ï°∞Î•º ÎßûÏ∂∞Ïïº Ìï©ÎãàÎã§.
                    // Ïó¨Í∏∞ÏÑúÎäî ÏûÑÏãúÎ°ú nullÏùÑ Î∞òÌôòÌïòÍ≥† Ï†ÑÏ≤¥ Î°úÏßÅÏùÑ ÏàòÏ†ïÌï©ÎãàÎã§.
                    // Ïã§Ï†úÎ°úÎäî QuizÎ•º DTOÎ°ú Î≥ÄÌôòÌïòÎäî Î°úÏßÅÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.
                    return new QuizResponseDTO(quiz.getId(), quiz.getTitle(), quiz.getCreatedAt(), List.of(new QuestionDTO(q.getId(), q.getQuestionText(), optionDTOs)));
                })
                .collect(Collectors.toList());
    }

    private boolean isRelated(String tag, String[] words) {
        return Arrays.stream(words)
                .anyMatch(word -> tag.toLowerCase().contains(word) || word.toLowerCase().contains(tag));
    }

    @Transactional
    @Override
    public QuizResultResponseDTO checkQuizAnswers(Long quizId, List<UserAnswerDTO> userAnswers) {
        Quiz quiz = quizRepository.findById(quizId)
                .orElseThrow(() -> new RuntimeException("ÌÄ¥Ï¶àÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."));

        int correctCount = 0;
        List<Boolean> results = new ArrayList<>();

        for (UserAnswerDTO userAnswer : userAnswers) {
            AnswerOption selectedOption = answerOptionRepository.findById(userAnswer.getAnswerOptionId())
                    .orElseThrow(() -> new RuntimeException("ÏÑ†ÌÉùÌïú Î≥¥Í∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."));

            boolean isCorrect = selectedOption.getIsCorrect();
            if (isCorrect) {
                correctCount++;
            }
            results.add(isCorrect);
        }

        int score = (int) ((double) correctCount / quiz.getQuestions().size() * 100);

        return new QuizResultResponseDTO(score, results);
    }

    @Transactional
    @Override
    public List<QuestionWithOptionsResponseDTO> getQuestionsFromUserAnswers(List<UserAnswerDTO> answers) {
        List<QuestionWithOptionsResponseDTO> response = new ArrayList<>();

        for (UserAnswerDTO ua : answers) {
            AnswerOption selectedOption = answerOptionRepository.findById(ua.getAnswerOptionId())
                    .orElseThrow(() -> new RuntimeException("ÏÑ†ÌÉùÌïú Î≥¥Í∏∞ ÏóÜÏùå"));

            Question q = selectedOption.getQuestion();

            List<OptionDTO> optionDtos = q.getOptions().stream()
                    .map(opt -> new OptionDTO(opt.getId(), opt.getOptionText()))
                    .toList();

            response.add(new QuestionWithOptionsResponseDTO(q.getId(), optionDtos));
        }

        return response;
    }

    @Override
    public String callOpenAISummary(String fullPrompt) {
        return openAIClient.chat(fullPrompt).block();
    }

    private List<String> splitTextIntoChunks(String text, int chunkSize) {
        List<String> chunks = new ArrayList<>();
        int length = text.length();
        for (int start = 0; start < length; start += chunkSize) {
            int end = Math.min(length, start + chunkSize);
            chunks.add(text.substring(start, end));
        }
        return chunks;
    }

    private synchronized Tag findOrCreateTag(String tagName) {
        return tagRepository.findByTagName(tagName)
                .orElseGet(() -> tagRepository.save(Tag.builder().tagName(tagName).build()));
    }


}